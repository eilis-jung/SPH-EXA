#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive :enable

#include "constants.h"
#include "structures.h"

#define NUM_MODEL_VERTICES 36

// Old elements
layout(set = 0, binding = 0) buffer ElementsA {
	Element elementsA[];
};

layout(set = 0, binding = 1) buffer ElementsB {
	Element elementsB[];
};

layout(set = 0, binding = 2) buffer UniformNumElements {
	int numElements;   
};

layout(set = 0, binding = 3) buffer Vertices {
	Vertex vertices[];   
};

mat4 buildMat(vec3 translation, vec3 scale)
{
	float scaleX = max(scale.x, 0.1);
	float scaleY = max(scale.y, 0.1);
	float scaleZ = max(scale.z, 0.1);
	vec3 trans = translation * 0.0001;
	trans = vec3(0.f);
    mat4 res = mat4(
        vec4(scaleX, 0.0, 0.0, 0.0),
        vec4(0.0, scaleY, 0.0, 0.0),
        vec4(0.0, 0.0, scaleZ, 0.0),
        vec4(trans, 1.0));
	// res = transpose(res);
	return res;
}

// Compute vertices position
void main() {
	const int NUM_TOTAL_VERTICES = numElements * NUM_MODEL_VERTICES;
	uint index = gl_GlobalInvocationID.x;
    if (index >= NUM_TOTAL_VERTICES)
		return;
	
	int elementID = int(index) / NUM_MODEL_VERTICES;
	mat4 modelMat = elementsA[elementID].modelMat;
	modelMat = mat4(
		elementsA[elementID].mati3,
		elementsA[elementID].mati0,
		elementsA[elementID].mati1,
		elementsA[elementID].mati2
	);
	// modelMat = mat4(
		
	// 	elementsA[elementID].mati0,
	// 	elementsA[elementID].mati1,
	// 	elementsA[elementID].mati2,
	// 	elementsA[elementID].mati3
	// );
	modelMat = transpose(modelMat);
	// vertices[index].position = modelMat * vertices[index].position;
	
	// vertices[index].color = vec4(elementsA[elementID].mati2.yzw, 1.0);
}